#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

#!csharp

#r "nuget:ScottPlot, 5.0.35"
using Microsoft.DotNet.Interactive.Formatting;
using System.Threading;
using System.Diagnostics;
using System.Collections.Concurrent;

var BlockingCollection = new BlockingCollection<object>();
var ConcurrentQueue = new ConcurrentQueue<object>();
var Queue = new Queue();
Stopwatch sw = new Stopwatch();

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
    
ScottPlot.Plot plt = new();
plt.XLabel("Итерации");
plt.YLabel("Время");

ScottPlot.Plot plt1 = new();
ScottPlot.Plot plt2 = new();

const int Count = 1000000;
int NumTest = 10;

#!csharp

double TestBlockingCollection()
    {
        var bcY = new List<double>();
        List<double> iteratsX = new List<double> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        for (int i = 0; i <  NumTest; i++)
        {
            var bc = new BlockingCollection<int>();
            var readyEvent = new ManualResetEvent(false);
            var stopwatch = new Stopwatch();

            var  aThread = new Thread(() =>
            {
                readyEvent.WaitOne();
                stopwatch.Start();
                for (int j = 0; j < Count; j++)
                {
                    bc.Add(j);
                }
                stopwatch.Stop();
            });

            var bThread = new Thread(() =>
            {
                readyEvent.Set();
                while (bc.Count < Count) { }
                while (bc.Take() != Count - 1) { }
            });

            aThread.Start();
            bThread.Start();
            aThread.Join();
            bThread.Join();

            bcY.Add(stopwatch.Elapsed.TotalMilliseconds);
        }

        Console.WriteLine($"Среднее время BlockingCollection: {bcY.Average()}мс");
        var graph1 = plt.Add.Scatter(iteratsX.ToArray(), bcY.ToArray());
        graph1.LegendText = "BlockingCollection";
        return bcY.Average();
    }

#!csharp

double TestConcurrentQueue()
    {
        var cqY = new List<double>();
        List<double> iteratsX = new List<double> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

        for (int i = 0; i < NumTest; i++)
        {
            var cq = new ConcurrentQueue<int>();
            var readyEvent = new ManualResetEvent(false);
            var stopwatch = new Stopwatch();

            var aThread = new Thread(() =>
            {
                readyEvent.WaitOne();
                stopwatch.Start();
                for (int j = 0; j <  Count; j++)
                {
                    cq.Enqueue(j);
                }
                stopwatch.Stop();
            });

            var bThread = new Thread(() =>
            {
                readyEvent.Set();
                int x;
                while (cq.Count < Count) { }
                while (cq.TryDequeue(out x) && x != Count - 1) { }
            });

            aThread.Start();
            bThread.Start();
            aThread.Join();
            bThread.Join();

            cqY.Add(stopwatch.Elapsed.TotalMilliseconds);
        }
        var graph2 = plt.Add.Scatter(iteratsX.ToArray(), cqY.ToArray());
        graph2.LegendText = "ConcurrentQueue";
        Console.WriteLine($"Среднее время ConcurrentQueue: {cqY.Average()}мс");
        return cqY.Average();
}

#!csharp

void TestNotSafeQueue()
    {
        List<double> iteratsX = new List<double> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        var results = new List<double>();
        for (int i = 0; i < NumTest; i++)
        {
            var queue = new Queue<int>();
            var stopwatch = new Stopwatch();

            stopwatch.Start();
            for (int j = 0; j < Count; j++)
            {
                queue.Enqueue(j);
            }
            stopwatch.Stop();
            var enqueueTime = stopwatch.Elapsed.TotalMilliseconds;

            stopwatch.Restart();
            while (queue.Count > 0)
            {
                queue.Dequeue();
            }
            stopwatch.Stop();
            var dequeueTime = stopwatch.Elapsed.TotalMilliseconds;

            results.Add(enqueueTime + dequeueTime);
        }
        var graph3 = plt.Add.Scatter(iteratsX.ToArray(), results.ToArray());
        graph3.LegendText = "Непотокобезопасная очередь";
        Console.WriteLine($"Среднее время непотокобезопасной очереди: {results.Average()}мс");
        var minimum = Math.Min(TestBlockingCollection(), TestConcurrentQueue());
        double procent = ((minimum - results.Average())/results.Average())*100;
        Console.WriteLine($"Среднее время самой быстрой потоко-безопасной коллекции (ConcurrentQueue) составляет: {procent}% от времени обычной очереди");
    }

#!csharp

TestNotSafeQueue();

plt.ShowLegend(ScottPlot.Edge.Bottom);
plt

#!markdown

## Вывод

Самой быстрой потокобезопасной коллекцией является ConcurrentQueue

Среднее время непотокобезопасной очереди: 22.30261мс
Среднее время BlockingCollection: 168.57327999999998мс
Среднее время ConcurrentQueue: 39.83073мс
Среднее время самой быстрой потоко-безопасной коллекции (ConcurrentQueue) составляет: 78.59223651402235% от времени обычной очереди
