#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

using System.Collections.Concurrent;
using System.Threading;
using System.Collections.Generic;

public interface ICommand
{
    void Execute();
}

#!csharp

public class ServerThread
{
    private BlockingCollection<ICommand> _commandQueue = new BlockingCollection<ICommand>();
    private Thread _thread;
    private bool _isRunning = true;

    public ServerThread()
    {
        _thread = new Thread(Run);
        _thread.Start();
    }

    private void Run()
    {
        while (_isRunning)
        {
            try
            {
                var command = _commandQueue.Take();
                command.Execute();
            }
            catch (InvalidOperationException)
            {

            }
        }
    }

    public void AddCommand(ICommand command)
    {
        _commandQueue.Add(command);
    }

    public void HardStop()
    {
        _isRunning = false;
        _commandQueue.CompleteAdding();
        _thread.Join();
    }

    public void SoftStop()
    {
        _isRunning = false;
    }
}

#!csharp

public class HardStop : ICommand
{
    private ServerThread _serverThread;

    public HardStop(ServerThread serverThread)
    {
        _serverThread = serverThread;
    }

    public void Execute()
    {
        _serverThread.HardStop();
    }
}

#!csharp

public class SoftStop : ICommand
{
    private ServerThread _serverThread;

    public SoftStop(ServerThread serverThread)
    {
        _serverThread = serverThread;
    }

    public void Execute()
    {
        _serverThread.SoftStop();
    }
}

#!csharp

public class Comande : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Команда выполнена");
    }
}

#!csharp

public static void Test()
    {
        ServerThread serverThread = new ServerThread();
        serverThread.AddCommand(new Comande());
        serverThread.AddCommand(new Comande());
        serverThread.AddCommand(new Comande());
        serverThread.AddCommand(new SoftStop(serverThread));
        serverThread.AddCommand(new Comande());
       
        Thread.Sleep(2000);
        Console.WriteLine("Soft-Test завершен");
        serverThread.AddCommand(new Comande()); 
        serverThread.AddCommand(new Comande()); 
        serverThread.AddCommand(new Comande());
        serverThread.AddCommand(new HardStop(serverThread));
        serverThread.AddCommand(new Comande());
        Thread.Sleep(2000);
        
        
        Console.WriteLine("Hard-Test завершен");
    }

Test();

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.
